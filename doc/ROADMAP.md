# **Project SNN: 新開発ロードマップ v9.0**

## **― デジタル生命体の創成：堅牢な基盤から社会性の創発へ ―**

### **1\. 序論：自己進化するデジタル生命体へ**

本プロジェクトは、単なるSNN（スパイキングニューラルネットワーク）のシミュレーションを超え、「自己進化するデジタル生命体」の構築という極めて野心的なビジョンを掲げる、先進的な研究開発フレームワークである。

分析の結果、プロジェクトはすでに以下の重要なマイルストーンを達成している：

* **🧠 統合認知アーキテクチャの完成:** 知覚、記憶、情動、意思決定といった個別の認知モジュールが ArtificialBrain として統合され、一貫した認知サイクルを実行するプロトタイプが完成している。  
* **🚀 先進的な自己進化機能の実装:** エージェントが自身の性能を評価し、モデルのアーキテクチャや学習パラダイム自体をも自律的に変更する、高度な自己進化の仕組みが実装されている。  
* **脱・勾配学習への挑戦:** 誤差逆伝播法に依存しない、STDPや因果追跡クレジット割り当てといった、生物学的に妥当な学習則が実装されている。  
* **✨ 壮大なビジョンの文書化:** プロジェクトの思想的背景、戦略、そして目指すべき未来像が、多数の設計・戦略ドキュメントにまとめられており、明確な指針が存在する。

本ロードマップv9.0は、これらの優れた基盤の上に、プロジェクトを次なる飛躍へと導くための戦略的な設計図である。

### **2\. プロジェクト進化のための3段階戦略**

研究開発フェーズから、安定して動作し、誰もがその能力を探求できる「基盤整備と価値実証フェーズ」へと移行するため、以下の3つの段階的な戦略を実行する。

#### **2.1. 【短期戦略】 堅牢性と再現性の強化 (Foundation)**

**目的:** プロジェクトの信頼性を保証し、開発者が容易にシステムを操作・検証できる環境を構築する。

* **✅ 包括的なテストスイートの完成:** CI/CDパイプラインと連携したコードカバレッジ80%以上を達成し、将来の機能追加やリファクタリングに対する安全網を確立する。  
* **🛠️ 統合CLIツールの完成:** snn-cli.py に brain loop（対話モード）などの機能を完全に実装し、人工脳の全機能をコマンドラインから直接、かつ容易に操作できるようにする。  
* **📖 ドキュメントとチュートリアルの拡充:** SNN\_Project\_Colab\_Quickstart.ipynb を拡張し、各認知モジュールの動的な連携や自己進化のプロセスを可視化・体験できる、よりインタラクティブなチュートリアルを提供する。

#### **2.2. 【中期戦略】 ANNを超える独自価値の追求 (Differentiation)**

**目的:** 静的なデータセットでANNと性能を競う「レッドオーシャン」から脱却し、SNNが本質的に優位な領域で圧倒的な価値を実証する「ブルーオーシャン」を開拓する。

* **⚡ イベント駆動センサーとの融合:** プロジェクトの「キラーアプリケーション」として**DVS (Dynamic Vision Sensor)** を全面的に採用する。DVSから得られるスパースで時間的なデータはSNNの計算原理と完全に一致しており、ANNでは達成不可能な超低遅延・超低消費電力のリアルタイム認識システムを実現できる。  
* **📚 継続学習能力の実証:** ANNの致命的な弱点である「破局的忘却」の克服を、プロジェクトの明確なマイルストーンに設定する。EWC（Elastic Weight Consolidation）損失などを活用し、**複数のタスクを逐次的に学習させても過去のタスクの性能が低下しないこと**を実証するベンチマークを構築・公開する。

#### **2.3. 【長期戦略】 自律性の深化と社会性の創発 (Emergence)**

**目的:** プロジェクトの究極の目標である「デジタル生命体」へと到達するために、個々のエージェントの知性を深め、エージェント間の相互作用を可能にする。

* **💡 記号創発システムの完成と自己言及能力の獲得:** SymbolGrounding モジュールを認知サイクルに深く統合し、AIが自らの内部状態から自律的に概念（シンボル）を形成し、それを用いて推論するループを完成させる。これにより、AI自身の内省に基づいた自己言及能力を獲得する。  
* **🌐 マルチエージェントによる社会学習の実現:** DistributedModelRegistry と EmergentCognitiveSystem の基盤を発展させ、各エージェントが学習した「スキル（専門家モデル）」を共有し、互いに教え合う\*\*「社会学習」\*\*のメカニズムを構築する。これにより、個々のエージェントの学習をはるかに超える速度で、システム全体の知性が指数関数的に成長することを目指す。

## **3\. 実装ロードマップ：認知アーキテクチャの成熟**

**目的:** 現在抽象化されている認知モジュールを、設計書で描かれた、より現実に即した高性能な実装に置き換える。

### **フェーズ1：高忠実度な知覚 (High-Fidelity Perception) (完了)**

* **目標:** 現在の単純な特徴抽出ロジックを持つPerceptionCortexを、SNNとCNN（畳み込みニューラルネットワーク）の長所を組み合わせた、高性能なハイブリッドモデルに置き換える。  
* **主要技術:**  
  * **ハイブリッドアーキテクチャ:** 軽量な事前学習済みCNN（例: MobileNetV2）を特徴抽出器として利用し、その出力をスパイク系列に変換。後段のSNN（SomFeatureMapやSpikingTransformer層）が、抽出された特徴の時間的ダイナミクスを処理する。  
  * **ANN-SNN変換:** AnnToSnnConverterを活用し、CNN部分の重みを効率的にSNN互換の形式に変換する技術を探求する。  
* **実装計画:**  
  1. snn\_research/cognitive\_architecture/内にhybrid\_perception\_cortex.pyを新規作成する。  
  2. BrainContainerを修正し、PerceptionCortexのプロバイダを新しいHybridPerceptionCortexに切り替え可能にする。  
* **達成指標:** イベントベースの視覚データセット（例: N-MNIST）において、現在のPerceptionCortexと比較して認識精度が大幅に向上する。

### **フェーズ2：動的かつ情動的な意思決定 (Dynamic and Emotional Decision Making) (完了)**

* **目標:** Amygdala（扁桃体）によって評価された情動価を、BasalGanglia（大脳基底核）の行動選択プロセスに統合し、より文脈に応じた動的な意思決定を実現する。  
* **主要技術:**  
  * **情動変調:** Amygdalaが算出する情動価（Valence）と覚醒度（Arousal）に基づき、BasalGangliaの行動選択閾値や抑制の強さを動的に変更する。例えば、高い覚醒度と負の情動価（危険を察知）は、より迅速で防御的な行動選択を促す。  
  * **目標の再評価:** PrefrontalCortexが目標を設定する際に、現在の情動状態を考慮に入れる。  
* **実装計画:**  
  1. ArtificialBrainのrun\_cognitive\_cycleメソッドを修正し、Amygdalaの出力をBasalGangliaとPrefrontalCortexに伝達するフローを実装する。  
  2. BasalGangliaのselect\_actionメソッドを拡張し、情動状態に応じて内部パラメータを調整するロジックを追加する。  
* **達成指標:** 同じ状況でも、異なる情動状態（例: 快・不快）を与えることで、ArtificialBrainが異なる行動を選択することを確認する。

### **フェーズ3：記憶の固定と能動的想起 (Memory Consolidation and Active Recall) (完了)**

* **目標:** Hippocampus（海馬）の短期記憶とCortex（大脳皮質）の長期記憶の連携を強化し、睡眠中などに起こる「記憶の固定」プロセスと、計画立案時に長期記憶を能動的に「想起」するプロセスをシミュレートする。  
* **主要技術:**  
  * **記憶固定プロセス:** ArtificialBrainに、定期的に（または低負荷時に）Hippocampusに蓄積された最近のエピソードをCortexのナレッジグラフに変換・統合するバックグラウンドプロセスを実装する。  
  * **能動的想起:** HierarchicalPlannerが計画を立案する際に、まずCortexのナレッジグラフを検索し、関連する過去の知識（成功・失敗体験）を計画の参考にできるようにする。  
* **実装計画:**  
  1. ArtificialBrainにconsolidate\_memoriesメソッドを追加する。  
  2. HierarchicalPlannerのcreate\_planメソッドを修正し、計画立案の初期段階でCortexを検索するロジックを組み込む。  
* **達成指標:** 一度経験したタスクに再度直面した際、エージェントが長期記憶を参照し、初回よりも効率的な計画を立案できる。

### **フェーズ4：CLIによる中央制御 (Centralized Control via CLI)**

* **目標:** snn-cli.pyを拡張し、人工脳全体のシミュレーションを開始・操作するための統一されたインターフェースを提供する。  
* **実装計画:**  
  1. snn-cli.pyに新しいサブコマンドグループbrainを追加する。  
  2. brain runコマンドを実装する。このコマンドは、内部でBrainContainerをセットアップし、run\_brain\_simulation.pyと同様の認知サイクルを、コマンドラインから与えられた単一の入力に対して実行する。  
  3. brain loopコマンドを実装し、複数の入力を対話的に与えながら認知サイクルを連続実行できるようにする。  
* **達成指標:** run\_brain\_simulation.pyを直接実行することなく、snn-cli.py brain run \--input\_text "some text"のようなコマンドでArtificialBrainの全機能が実行可能になる。

### **フェーズ5：包括的なテストスイートの拡充 (Comprehensive Test Suite Expansion) (完了)**

* **目標:** プロジェクトの信頼性を保証するため、テストカバレッジを大幅に向上させ、システムの安定性を確保する。  
* **主要技術:** pytestおよびpytest-covカバレッジ測定ツール。  
* **実装計画:**  
  1. **単体テストの拡充:** 各認知モジュールの単体テスト（tests/cognitive\_architecture/test\_cognitive\_components.py）を拡充し、エッジケース（例: 空の入力、予期しないデータ型）のカバレッジを向上させる。  
  2. **統合テストの深化:** ArtificialBrainの統合テスト（tests/cognitive\_architecture/test\_artificial\_brain.py）を強化し、単にエラーなく実行されることだけでなく、各モジュールの状態が意図通りに変化したか（例: Hippocampusにエピソードが正しく記録されたか）をアサーションで確認する。  
  3. **CLIテストの追加:** snn-cli.pyに追加されたbrainコマンドが、期待通りに動作することを検証するテストを追加する。  
* **達成指標:** pytest-covによるテストカバレッジ測定で、snn\_research/cognitive\_architectureパッケージのコードカバレッジ80%以上を達成する。

### **フェーズ6：ニューロモーフィック展開パイプライン (Neuromorphic Deployment Pipeline)**

* **目標:** NeuromorphicCompilerの機能を拡張し、生成されたハードウェア構成ファイルを用いて、ターゲットハードウェア上での性能（速度、エネルギー消費）をより正確に予測できるシミュレーションパイプラインを構築する。  
* **主要技術:**  
  * **ハードウェア・イン・ザ・ループ・シミュレーション:** 生成されたYAML構成ファイルを読み込み、hardware/profiles.pyで定義されたエネルギー消費モデルに基づいて、ビット精度のシミュレーションを実行する機能を追加する。  
  * **学習則のコンパイル:** NeuromorphicCompilerを拡張し、ネットワーク構造だけでなく、STDPのような局所学習則もハードウェア命令に変換する研究に着手する（Intel Loihi 2のオンチップ学習機能などを想定）。  
* **実装計画:**  
  1. NeuromorphicCompilerに、コンパイル済みYAMLファイルを実行し、性能レポートを出力するsimulate\_on\_hardwareメソッドを追加する。  
  2. scripts/run\_compiler\_test.pyを更新し、コンパイル後のシミュレーションまでを実行・検証するようにする。  
* **達成指標:** 同じSNNモデルでも、異なるハードウェアプロファイル（例: default vs 架空のlow\_power\_edge）でシミュレーションした際に、エネルギー消費や処理速度に理論的に妥当な差が見られることを確認する。
